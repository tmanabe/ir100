# 9. シャーディングとレプリケーション

## 0. 準備

前章で作成したWebサーバ（以下、検索エンジンと呼ぶ）を異なるポートで2つ立ち上げよ。それぞれ**シャード0, シャード1**と呼んで区別する。

## 1. 並列更新

以下のエンドポイントを持つ新たなWebサーバを実装せよ。

- `/update`: 製品（複数可）をHTTP POSTすると、各 `product_id` のMD5を計算する。その2の剰余が0の製品をまとめてシャード0の、1の製品をまとめてシャード1の、同名のエンドポイントに並列に転送する。

以下、このWebサーバを**ルータ**と呼ぶ。

## 2. 並列更新ベンチマーク

ルータを介して `8.5` を行え。所要時間が有意に短縮することを確かめよ。

> ヒント：実行環境のリソースが枯渇した場合、もちろん短縮しないので注意せよ。

## 3. 並列検索

ルータに新たに以下のエンドポイントを実装せよ。

- `/select`: `query` をHTTP GETすると、両シャードの同名のエンドポイントに並列に転送する。両レスポンスが揃ったら、製品をまとめて並べ直し、出現回数の降順で上位10件まで返す（つまり、下位10件までを捨てる）。

## 4. 並列検索ベンチマーク

ルータを介して `8.6` を行え。所要時間の短縮を確かめよ。

## 5. レスポンスの分割

ルータにおける `/select` の処理では半数の製品が捨てられる可能性がある。捨てられる `product_title` の通信を省くため、以下のようにルータ-検索エンジン間でリクエスト/レスポンスが2往復する実装に改善せよ。

- 第1往復では、レスポンスは優先度と `product_id` のみを含む。これだけの情報があればルータで製品の並べ直しを行うことができることに注意せよ。
- 第2往復では、レスポンスは並べ直しの結果上位の `product_title` のみを含む。

ただし、この改善はわずか2シャードの環境では有意でない可能性があるので、既存の機能とはエンドポイントを分けること。なお、検索エンジンの実装の改善も必要である。

## 6. レプリケーション

検索エンジンを異なるポートで4つ立ち上げよ。それぞれ**シャード0レプリカ0, シャード0レプリカ1, シャード1レプリカ0, シャード1レプリカ1**と呼んで区別する。

ルータで `/update` の処理を行うとき、シャードごとの両レプリカに**同じ**製品を並列に転送するようにせよ。再度ルータを介して `8.5` を行え。所要時間は短縮しないが、伸長もしないことを確かめよ。

## 7. 4並列

2レプリカの環境では、ルータで `/select` の処理を行うとき、（シャード0レプリカ0, シャード1レプリカ0）のペアまたは（シャード0レプリカ1, シャード1レプリカ1）のペアに並列に転送することが考えられる。これを実装し、再度 `4.` を行え。所要時間の更なる短縮を確かめよ。

## 8. 動的レプリケーション

レプリカを動的に増やせるようにせよ。ここで動的であるとは、既存の検索エンジンやルータを立ち上げ直したり、ルータから全ての製品を `/update` し直したりする必要が**ない**ことを指す。

## 9. 動的シャーディング

シャードを動的に増やせるようにせよ。
