# 8. インデックスのライフサイクル

## 0. 準備

以下のエンドポイントを持つWebサーバを実装せよ。ただし、入出力のフォーマットはJSONとせよ。JSONのスキーマは自由とする。

- `/update` : 製品（複数可）をHTTP POSTすると、`product_title` をスペースで区切り、転置インデックスを構築して保持する。
- `/select` : `query` をHTTP GETすると、それを単語と解釈して（つまり、複数の単語の入力に対応する必要はない）保持している転置インデックスを引き、出現回数の降順で上位10件までの `product_id` を返す。

また、適当な製品を `/update` し、`/select` して動作確認をせよ。動作確認のために、`product_title` も保持しておき、`product_id` および出現回数と共に返すようにせよ。この動作のためには転置インデックスの他、追加のデータ構造も必要になるが、以降これらをまとめて**セグメント**と呼ぶ。

## 1. 挿入

1回のHTTP POSTのサイズには限界があるので、複数回の `/update` に対応せよ。ただし、既存の転置インデックスを効率よく変更するのは難しいので、`/update` のたびに追加のセグメントを保持せよ。`/select` の際は、保持しているセグメント全てを走査し、単一のレスポンスにまとめよ。

また、適当な製品を複数回に分けて `/update` し、`/select` して動作確認をせよ。

## 2. 論理削除

新たに以下のエンドポイントを実装せよ。

- `/delete` : `product_id`（複数可）をHTTP GETすると、それらを以降の `/select` の対象から外す。

ただし、既存の転置インデックスを効率よく変更するのは難しいので、`product_id` ごとの生存フラグをセグメントに含める。`/update` の際に立て、`/delete` の際に倒し、`/select` の際に参照する実装とせよ。

また、適当な製品を `/update` し、その一部を `/delete` し、`/select` して動作確認をせよ。

## 3. 更新

既存の製品と同じ `product_id` の製品が `/update` されたとき、既存の製品の生存フラグを倒すようにせよ。また、適当な製品を `/update` し、同じ `product_id` の製品を `/update` し、`/select` して動作確認をせよ。

## 4. マージと物理削除

セグメントが増えるとオーバヘッドが生じる。そこで、`/update` によってセグメントが11個になったら、製品数が少ない順に2個のセグメントを1個のセグメントにマージすることで、常に高々10個のセグメントを保存するようにせよ。このとき、生存フラグが倒れている製品は削除せよ。

## 5. 更新ベンチマーク

題材の製品データ全件をX分以内で `/update`（挿入）できるようにせよ。さらに、その状態からシャッフルした題材の製品データ全件をY分以内で `/update`（更新）できるようにせよ。

## 6. 検索ベンチマーク

題材の製品データの `product_title` からランダムにZ単語をサンプリングせよ。それらの単語で順に `/select` して合計の所要時間を測定せよ。

## 7. 最適化

新たに以下のエンドポイントを実装せよ。

- `/optimize` : セグメントが1個になるまでマージを繰り返す。

`/optimize` 後、`6.` を再度行い、所要時間を比較せよ。

## 8. 排他制御

一般にWebサーバはリクエストを並列処理する。この場合にも問題がないよう、セグメントのRead/Writeロックを行え。

## 9. コミット

新たに以下のエンドポイントを実装せよ。

- `/commit`

`/delete` および `/update` は、その後 `/commit` するまで `/select` の結果に影響しないようにせよ。
