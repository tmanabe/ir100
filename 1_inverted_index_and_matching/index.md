# 1. 転置インデックスとマッチング

（想定実行時間：それぞれ1分以内）

## 0. 準備

題材の製品データから `product_locale` が `us` であるものを抽出せよ。

これ以降、以下の理由からこのサブセットを用いる。

- スペースで区切れば簡易的にトークナイズできると考えられるため
- もし `product_locale` をまたいだ場合、`product_id` がユニークでなくなるため

## 1. ディクショナリ

`product_title` フィールドに出現する単語をキーとし、出現回数（全ての製品の合計）を値とする連想配列を構築せよ。
ただし、単語はスペースで区切られているものとする（以降の問題でも同じ）。

また、この連想配列のエントリ数（単語の異なり数）が約90万であることを確かめよ。

## 2. ポスティングリスト

単語 `Information` を `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。ただし、`product_id` は辞書順とし、重複してはならない（以降の問題でも同じ）。

また、この配列の要素数が110であることを確かめよ。

## 3. 転置インデックス

以下の連想配列を構築せよ：

- キー：題材の製品データで `product_title` フィールドに出現する単語
- 値：その単語を `product_title` フィールドに含む製品の `product_id` の配列

また、この連想配列について、以下のことを確かめよ：

- エントリ数が `1.` の連想配列のそれと等しいこと
- `Information` に紐づいた配列が `2.` の配列と等しいこと

以降、このデータ構造を転置インデックスと呼ぶ。また、転置インデックスの値をポスティングリストと呼ぶ。

## 4. 永続化

転置インデックスをメモリからディスクに書き込んだり、ディスクからメモリに読み込んだりできるようにせよ。

## 5. ブーリアンAND検索

転置インデックスを用いて、2単語 `Information` と `Science` を**ともに** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。ただし、配列が非常に長い場合にも効率的なコードにせよ（以降の問題でも同じ）。

また、この配列の要素数が3であることを確かめよ。

## 6. ブーリアンOR検索

転置インデックスを用いて、2単語 `Information` と `Retrieval` の**少なくとも片方を** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。

また、この配列の要素数が129であることを確かめよ。

## 7. 条件の否定

`5.` の条件を**満たさず**、かつ、`6.` の条件を満たす製品の `product_id` の配列を出力せよ。

また、この配列の要素数が126であることを確かめよ。

## 8. 完全一致

`product_brand` フィールドに関する転置インデックスを構築せよ。ただし単語に区切らず、フィールドの値をそのまま連想配列のキーとすること。

## 9. 複数フィールドの横断

転置インデックスを用いて、`product_title` フィールドに単語 `Amazon` を含み、かつ、`product_brand` フィールドの値が `Amazon Basics` **ではない**製品の数が8,681であることを確かめよ。
