# 1. 転置インデックスとマッチング

（想定実行時間：それぞれ1分以内）

## 1. ディクショナリ

英語製品データについて、以下の連想配列を構築せよ。
ただし、単語はスペースで区切られているものとする（以降の問題でも同じ）。

- キー： `product_title` フィールドに出現する単語。
- 値：その単語の出現回数。ただし、全ての製品における合計とする。

また、単語の異なり数が約90万であることを確かめよ。

## 2. ポスティングリスト

単語 `Information` を `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。
ただし、`product_id` は辞書順とし、重複してはならない（以降の問題でも同じ）。

また、この配列の要素数が110であることを確かめよ。

## 3. 転置インデックス

以下の連想配列を構築せよ：

- キー：`product_title` フィールドに出現する単語。
- 値：その単語を `product_title` フィールドに含む製品の `product_id` の配列。

また、この連想配列について、以下のことを確かめよ：

- エントリ数が `1.` の連想配列のそれと等しいこと。
- `Information` に紐づいた配列が `2.` の配列と等しいこと。

以降、このデータ構造を**転置インデックス**、転置インデックスの値を**ポスティングリスト**と呼ぶ。

## 4. 永続化

転置インデックスをメモリからディスクに書き込んだり、ディスクからメモリに読み込んだりできるようにせよ。

## 5. ブーリアンAND検索

転置インデックスを用いて、2単語 `Information` と `Science` を**ともに** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。
ただし、配列が非常に長い場合にも効率的なコードにせよ（以降の問題でも同じ）。

また、この配列の要素数が3であることを確かめよ。

## 6. ブーリアンOR検索

転置インデックスを用いて、2単語 `Information` と `Retrieval` の**少なくとも片方を** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。

また、この配列の要素数が129であることを確かめよ。

## 7. 条件の否定

`5.` の条件を**満たさず**、かつ、`6.` の条件を満たす製品の `product_id` の配列を出力せよ。

また、この配列の要素数が126であることを確かめよ。

## 8. 完全一致

`product_brand` フィールドに関する転置インデックスを構築せよ。
ただし単語に区切らず、フィールドの値をそのまま連想配列のキーとすること。

## 9. 複数フィールドの横断

転置インデックスを用いて、`product_title` フィールドに単語 `Amazon` を含み、かつ、`product_brand` フィールドの値が `Amazon Basics` **ではない**製品の数が8,681であることを確かめよ。

## 10. プレフィックス

`3.` で構築した転置インデックスを圧縮する。
`product_id` が固定長であり、かつ辞書順にソートされていることを利用して、ポスティングリスト上で前の `product_id` と共通のプレフィックスを省略せよ。
このとき、ポスティングリストのイテレータ（`product_id` を復元して返す）も実装せよ。

## 11. 符号化

前問で構築した転置インデックスを更に圧縮する。
ポスティングリストとは別に全ての `product_id` の辞書順の配列を保存しておき、そのインデックスによってポスティングリストから `product_id` を参照するようにせよ。
また、イテレータも実装せよ。

## 12. Variable Byte Encoding

前問で構築した転置インデックスを更に圧縮する。
ポスティングリスト中のインデックスが単調増加することを利用して、前のインデックスからの差を保存せよ。
このとき、差は小さな整数になると期待されるので、variable byte encodingにより圧縮せよ。
また、イテレータも実装せよ。
